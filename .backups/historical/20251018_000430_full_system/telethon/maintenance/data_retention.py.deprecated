"""
Data Retention Service
–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∏–∑ PostgreSQL, Neo4j, Qdrant

Best practices (from Context7 + web research):
- PostgreSQL: batch DELETE + VACUUM OR –ø–∞—Ä—Ç–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
- Neo4j: DETACH DELETE —Å batch iterations (apoc.periodic.iterate)
- Qdrant: delete by filter (posted_at < cutoff_date)
- Sequential cleanup: PostgreSQL ‚Üí Neo4j ‚Üí Qdrant
"""
import logging
import os
from datetime import datetime, timedelta, timezone
from typing import Dict, Any, List

# Imports
import sys
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from database import SessionLocal
from models import Post, User
from rag_service.metrics import record_cleanup
import time

logger = logging.getLogger(__name__)


class DataRetentionService:
    """
    –°–µ—Ä–≤–∏—Å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è retention –ø–æ–ª–∏—Ç–∏–∫–æ–π
    
    Retention period: 120 –¥–Ω–µ–π (4 –º–µ—Å—è—Ü–∞) –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    Sync cleanup: PostgreSQL + Neo4j + Qdrant –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
    
    Usage:
        ```python
        retention = DataRetentionService(retention_days=120)
        
        # Dry run (–±–µ–∑ —É–¥–∞–ª–µ–Ω–∏—è)
        result = await retention.cleanup_all(dry_run=True)
        
        # –†–µ–∞–ª—å–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ
        result = await retention.cleanup_all(dry_run=False)
        ```
    """
    
    def __init__(self, retention_days: int = None):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è retention service
        
        Args:
            retention_days: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π —Ö—Ä–∞–Ω–µ–Ω–∏—è (default: –∏–∑ .env –∏–ª–∏ 120)
        """
        if retention_days is None:
            retention_days = int(os.getenv("DATA_RETENTION_DAYS", "120"))
        
        self.retention_days = retention_days
        self.cutoff_date = datetime.now(timezone.utc) - timedelta(days=retention_days)
        
        logger.info(f"üóëÔ∏è DataRetentionService initialized (retention: {retention_days} days)")
        logger.info(f"   Cutoff date: {self.cutoff_date.isoformat()}")
    
    async def cleanup_all(self, dry_run: bool = False) -> Dict[str, Any]:
        """
        –ì–ª–∞–≤–Ω—ã–π –º–µ—Ç–æ–¥: –æ—á–∏—Å—Ç–∫–∞ –≤—Å–µ—Ö –ë–î
        
        Args:
            dry_run: –ï—Å–ª–∏ True, —Ç–æ–ª—å–∫–æ –ø–æ–¥—Å—á–µ—Ç –±–µ–∑ —É–¥–∞–ª–µ–Ω–∏—è
        
        Returns:
            {
                "cutoff_date": "2024-10-14T...",
                "dry_run": True/False,
                "deleted_count": {
                    "postgres": 1500,
                    "neo4j": 1500,
                    "qdrant": 1500
                },
                "errors": []
            }
        
        Best practice: Sequential cleanup (PostgreSQL ‚Üí Neo4j ‚Üí Qdrant)
        –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è —Ä–∞—Å—Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏
        """
        logger.info(f"üßπ Starting cleanup (cutoff: {self.cutoff_date}, dry_run={dry_run})")
        
        stats = {
            "postgres": 0,
            "neo4j": 0,
            "qdrant": 0
        }
        errors = []
        
        # 1. PostgreSQL cleanup (source of truth)
        try:
            start = time.time()
            postgres_deleted = await self._cleanup_postgres(dry_run)
            duration = time.time() - start
            
            stats["postgres"] = postgres_deleted
            logger.info(f"‚úÖ PostgreSQL: {postgres_deleted} posts {'would be' if dry_run else ''} deleted")
            
            # Record metrics
            if not dry_run:
                record_cleanup('postgres', duration, postgres_deleted, success=True)
        except Exception as e:
            logger.error(f"‚ùå PostgreSQL cleanup failed: {e}", exc_info=True)
            errors.append(f"PostgreSQL: {str(e)}")
            record_cleanup('postgres', 0, 0, success=False)
        
        # 2. Neo4j cleanup (–µ—Å–ª–∏ Postgres —É—Å–ø–µ—à–Ω–æ)
        if stats["postgres"] > 0 or dry_run:
            try:
                start = time.time()
                neo4j_deleted = await self._cleanup_neo4j(dry_run)
                duration = time.time() - start
                
                stats["neo4j"] = neo4j_deleted
                logger.info(f"‚úÖ Neo4j: {neo4j_deleted} posts {'would be' if dry_run else ''} deleted")
                
                # Record metrics
                if not dry_run:
                    record_cleanup('neo4j', duration, neo4j_deleted, success=True)
            except Exception as e:
                logger.error(f"‚ùå Neo4j cleanup failed: {e}", exc_info=True)
                errors.append(f"Neo4j: {str(e)}")
                record_cleanup('neo4j', 0, 0, success=False)
        
        # 3. Qdrant cleanup (–ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ –¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π)
        try:
            start = time.time()
            qdrant_deleted = await self._cleanup_qdrant(dry_run)
            duration = time.time() - start
            
            stats["qdrant"] = qdrant_deleted
            logger.info(f"‚úÖ Qdrant: {qdrant_deleted} vectors {'would be' if dry_run else ''} deleted")
            
            # Record metrics
            if not dry_run:
                record_cleanup('qdrant', duration, qdrant_deleted, success=True)
        except Exception as e:
            logger.error(f"‚ùå Qdrant cleanup failed: {e}", exc_info=True)
            errors.append(f"Qdrant: {str(e)}")
            record_cleanup('qdrant', 0, 0, success=False)
        
        logger.info(f"‚úÖ Cleanup complete: {stats}")
        
        return {
            "cutoff_date": self.cutoff_date.isoformat(),
            "retention_days": self.retention_days,
            "dry_run": dry_run,
            "deleted_count": stats,
            "errors": errors,
            "timestamp": datetime.now(timezone.utc).isoformat()
        }
    
    async def _cleanup_postgres(self, dry_run: bool) -> int:
        """
        –£–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä—ã–µ –ø–æ—Å—Ç—ã –∏–∑ PostgreSQL
        
        Best practice: batch DELETE + VACUUM
        Alternative: –ø–∞—Ä—Ç–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ (—Å–º. plan)
        
        Returns:
            –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–¥–∞–ª–µ–Ω–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π
        """
        db = SessionLocal()
        try:
            # –ü–æ–¥—Å—á–∏—Ç–∞—Ç—å
            count_query = db.query(Post).filter(
                Post.posted_at < self.cutoff_date
            )
            count = count_query.count()
            
            logger.info(f"üìä PostgreSQL: {count} posts to delete")
            
            if dry_run:
                return count
            
            # –£–¥–∞–ª–∏—Ç—å
            if count > 0:
                deleted = count_query.delete(synchronize_session=False)
                db.commit()
                
                # VACUUM (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–¥–ª–µ–Ω–Ω—ã–º)
                # logger.info("üßπ Running VACUUM ANALYZE posts...")
                # db.execute("VACUUM ANALYZE posts")
                
                logger.info(f"‚úÖ PostgreSQL: deleted {deleted} posts")
                return deleted
            
            return 0
            
        except Exception as e:
            db.rollback()
            logger.error(f"‚ùå PostgreSQL cleanup error: {e}")
            raise
        finally:
            db.close()
    
    async def _cleanup_neo4j(self, dry_run: bool) -> int:
        """
        –£–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä—ã–µ Post nodes –∏–∑ Neo4j
        
        Best practice: DETACH DELETE —Å batch iterations
        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç apoc.periodic.iterate –¥–ª—è –±–æ–ª—å—à–∏—Ö –æ–±—ä–µ–º–æ–≤
        
        Returns:
            –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–¥–∞–ª–µ–Ω–Ω—ã—Ö nodes
        """
        try:
            from graph.neo4j_client import neo4j_client
            
            if not neo4j_client.enabled or not neo4j_client.driver:
                logger.warning("Neo4j disabled, skipping")
                return 0
        except ImportError:
            logger.warning("Neo4j client not available, skipping")
            return 0
        
        try:
            async with neo4j_client.driver.session() as session:
                # –ü–æ–¥—Å—á–∏—Ç–∞—Ç—å
                count_query = """
                MATCH (p:Post)
                WHERE p.created_at < $cutoff_date
                RETURN count(p) AS count
                """
                
                result = await session.run(
                    count_query,
                    cutoff_date=self.cutoff_date.isoformat()
                )
                record = await result.single()
                count = record["count"] if record else 0
                
                logger.info(f"üìä Neo4j: {count} posts to delete")
                
                if dry_run:
                    return count
                
                # –£–¥–∞–ª–∏—Ç—å (–ø—Ä–æ—Å—Ç–æ–π DETACH DELETE –¥–ª—è —Å—Ä–µ–¥–Ω–∏—Ö –æ–±—ä–µ–º–æ–≤)
                # –î–ª—è –±–æ–ª—å—à–∏—Ö –æ–±—ä–µ–º–æ–≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å apoc.periodic.iterate
                if count > 0:
                    if count < 10000:
                        # –ü—Ä–æ—Å—Ç–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ –¥–ª—è –º–∞–ª—ã—Ö –æ–±—ä–µ–º–æ–≤
                        delete_query = """
                        MATCH (p:Post)
                        WHERE p.created_at < $cutoff_date
                        DETACH DELETE p
                        RETURN count(p) AS deleted
                        """
                        
                        result = await session.run(
                            delete_query,
                            cutoff_date=self.cutoff_date.isoformat()
                        )
                        await result.consume()
                        deleted = count  # Approximate
                    else:
                        # Batch deletion –¥–ª—è –±–æ–ª—å—à–∏—Ö –æ–±—ä–µ–º–æ–≤
                        # –¢—Ä–µ–±—É–µ—Ç APOC plugin
                        delete_query = """
                        CALL apoc.periodic.iterate(
                          "MATCH (p:Post) 
                           WHERE p.created_at < $cutoff_date
                           RETURN p",
                          "DETACH DELETE p",
                          {batchSize: 5000, parallel: false}
                        )
                        YIELD batches, total
                        RETURN total
                        """
                        
                        try:
                            result = await session.run(
                                delete_query,
                                cutoff_date=self.cutoff_date.isoformat()
                            )
                            record = await result.single()
                            deleted = record["total"] if record else count
                        except Exception as e:
                            # Fallback –µ—Å–ª–∏ APOC –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
                            logger.warning(f"APOC unavailable, using simple delete: {e}")
                            delete_query = """
                            MATCH (p:Post)
                            WHERE p.created_at < $cutoff_date
                            DETACH DELETE p
                            """
                            await session.run(
                                delete_query,
                                cutoff_date=self.cutoff_date.isoformat()
                            )
                            deleted = count
                    
                    # Cleanup orphaned tags (—Ç–µ–≥–∏ –±–µ–∑ –ø–æ—Å—Ç–æ–≤)
                    cleanup_query = """
                    MATCH (t:Tag)
                    WHERE NOT (t)<-[:HAS_TAG]-(:Post)
                    DELETE t
                    """
                    await session.run(cleanup_query)
                    
                    logger.info(f"‚úÖ Neo4j: deleted ~{deleted} posts + orphaned tags")
                    return deleted
                
                return 0
                
        except Exception as e:
            logger.error(f"‚ùå Neo4j cleanup error: {e}")
            raise
    
    async def _cleanup_qdrant(self, dry_run: bool) -> int:
        """
        –£–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä—ã–µ –≤–µ–∫—Ç–æ—Ä—ã –∏–∑ Qdrant
        
        Best practice: delete by filter –¥–ª—è –∫–∞–∂–¥–æ–≥–æ user collection
        
        Returns:
            –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–¥–∞–ª–µ–Ω–Ω—ã—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤
        """
        try:
            from rag_service.qdrant_client import qdrant_client
        except ImportError:
            logger.warning("Qdrant client not available, skipping")
            return 0
        
        # –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        db = SessionLocal()
        try:
            users = db.query(User.id).all()
            
            total_deleted = 0
            
            for (user_id,) in users:
                collection_name = f"user_{user_id}_posts"
                
                try:
                    # –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏
                    collections = qdrant_client.get_collections()
                    if collection_name not in [c.name for c in collections.collections]:
                        continue
                    
                    # –ü–æ–¥—Å—á–∏—Ç–∞—Ç—å —á–µ—Ä–µ–∑ scroll (limit –¥–ª—è dry run)
                    if dry_run:
                        try:
                            vectors, _ = qdrant_client.scroll(
                                collection_name=collection_name,
                                scroll_filter={
                                    "must": [
                                        {
                                            "key": "posted_at",
                                            "range": {
                                                "lt": self.cutoff_date.isoformat()
                                            }
                                        }
                                    ]
                                },
                                limit=10000  # Max
                            )
                            
                            count = len(vectors) if vectors else 0
                            total_deleted += count
                            
                            if count > 0:
                                logger.debug(f"üìä Qdrant user_{user_id}: {count} vectors to delete")
                        except Exception as e:
                            logger.warning(f"‚ö†Ô∏è Qdrant scroll error for user {user_id}: {e}")
                        continue
                    
                    # –£–¥–∞–ª–∏—Ç—å
                    qdrant_client.delete(
                        collection_name=collection_name,
                        points_selector={
                            "filter": {
                                "must": [
                                    {
                                        "key": "posted_at",
                                        "range": {
                                            "lt": self.cutoff_date.isoformat()
                                        }
                                    }
                                ]
                            }
                        }
                    )
                    
                    # –ü–æ–¥—Å—á–µ—Ç –ø–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è (approximate)
                    total_deleted += 1  # Increment as proxy
                    logger.debug(f"‚úÖ Qdrant user_{user_id}: vectors deleted")
                    
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è Qdrant cleanup user {user_id} failed: {e}")
            
            return total_deleted
            
        finally:
            db.close()


# Global instance
retention_service = DataRetentionService()

