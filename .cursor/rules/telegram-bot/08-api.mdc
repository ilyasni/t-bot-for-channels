---
title: "API Endpoints"
description: "FastAPI endpoints, структура, authentication, best practices"
tags: ["api", "fastapi", "endpoints", "rest"]
version: "3.3"
ruleType: "autoAttached"
priority: medium
scope:
  - "telethon/main.py"
  - "telethon/api_*.py"
---

# API Endpoints

> **Rule Type:** Auto-Attached  
> **Lines:** < 500 (optimized)  
> **Priority:** Medium

## 🎯 High-Level Overview

**FastAPI сервер** (порт 8010) — REST API для интеграции с n8n, управления данными и Mini Apps.

**Essential Stack:**
- FastAPI (async only)
- Pydantic (validation)
- SQLAlchemy (ORM + user isolation)
- CORS middleware

**Critical Pattern:**
```python
# ✅ ВСЕГДА фильтруйте по user_id
query = db.query(Post).filter(Post.user_id == user_id)

# ❌ НИКОГДА без user_id фильтра
query = db.query(Post).all()  # NO! Data leak!
```

## 🚀 Essential Setup

### FastAPI Configuration

```python
# main.py
from fastapi import FastAPI, Depends, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI(
    title="Telegram Channel Parser API",
    version="3.3.0",
    docs_url="/docs"
)

# CORS (production: specific domains!)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # ⚠️ Production: specific domains
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"]
)

# Database dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

## 📋 Critical Patterns

### 1. User Isolation (MANDATORY!)

```python
# ✅ Correct - user_id filtering
@app.get("/posts")
async def get_posts(
    user_id: int,  # Required!
    db: Session = Depends(get_db)
):
    if not user_id:
        raise HTTPException(400, "user_id required")
    
    # Filter by user
    posts = db.query(Post).join(Post.channel).join(Channel.users).filter(
        User.id == user_id
    ).all()
    
    return {"posts": [serialize_post(p) for p in posts]}

# ❌ Bad - no user filtering
@app.get("/posts")
async def get_posts(db: Session = Depends(get_db)):
    posts = db.query(Post).all()  # NO! Returns all users' data!
    return {"posts": posts}
```

### 2. Subscription Limits

```python
# ✅ Correct - check user limits
@app.post("/channels")
async def add_channel(
    user_id: int,
    channel_username: str,
    db: Session = Depends(get_db)
):
    user = db.query(User).filter(User.id == user_id).first()
    
    # Check limit
    if len(user.channels) >= user.max_channels:
        raise HTTPException(
            403,
            f"Channel limit reached: {user.max_channels}"
        )
    
    # Add channel...
```

### 3. Background Tasks

```python
# ✅ Correct - non-blocking operations
@app.post("/parse_all_channels")
async def parse_all_channels(
    user_id: int,
    background_tasks: BackgroundTasks
):
    # Immediate response
    background_tasks.add_task(
        parser_service.parse_user_channels,
        user_id
    )
    return {"status": "queued"}

# ❌ Bad - blocking
@app.post("/parse_all_channels")
async def parse_all_channels(user_id: int):
    await parser_service.parse_user_channels(user_id)  # Blocks!
    return {"status": "done"}
```

## 🔐 Authentication Patterns

### Admin Decorator

```python
from functools import wraps

def require_admin(func):
    """Защита admin endpoints"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        admin_id = kwargs.get('admin_id')
        token = kwargs.get('token')
        
        if not admin_panel_manager.verify_admin_session(token, admin_id):
            raise HTTPException(403, "Unauthorized")
        
        return await func(*args, **kwargs)
    return wrapper

# Usage
@app.get("/api/admin/users")
@require_admin
async def get_users(admin_id: int, token: str, db: Session = Depends(get_db)):
    users = db.query(User).all()
    return {"users": [serialize_user(u) for u in users]}
```

### Rate Limiting

```python
def rate_limit(limit: int = 10, window: int = 60):
    """Rate limiting decorator"""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            user_id = kwargs.get('user_id')
            
            # Redis rate limit
            key = f"rate:{user_id}:{func.__name__}"
            current = redis_client.incr(key)
            
            if current == 1:
                redis_client.expire(key, window)
            
            if current > limit:
                raise HTTPException(429, f"Rate limit: {limit} req/{window}s")
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator

# Usage
@app.post("/rag/query")
@rate_limit(limit=10, window=60)
async def rag_query(user_id: int, query: str):
    pass
```

## 📝 Pydantic Validation

### Request/Response Schemas

```python
from pydantic import BaseModel, Field, validator
from typing import Optional, List

class PostResponse(BaseModel):
    id: int
    text: str
    channel_username: str
    posted_at: str
    url: Optional[str]
    tags: List[str] = []
    
    class Config:
        orm_mode = True

class ChannelCreate(BaseModel):
    channel_username: str = Field(..., min_length=1, regex="^[a-zA-Z0-9_]+$")
    
    @validator('channel_username')
    def validate_username(cls, v):
        if not v.startswith('@'):
            v = f"@{v}"
        return v

class UserUpdate(BaseModel):
    subscription_type: Optional[str] = Field(None, regex="^(free|trial|basic|premium|enterprise)$")
    max_channels: Optional[int] = Field(None, ge=1, le=999)
```

## 🏥 Health Check

```python
@app.get("/health")
async def health_check():
    """Comprehensive health check"""
    checks = {
        "database": await check_database(),
        "redis": await check_redis(),
        "qdrant": await check_qdrant()
    }
    
    all_healthy = all(checks.values())
    
    return {
        "status": "healthy" if all_healthy else "degraded",
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "checks": checks,
        "version": "3.3.0"
    }

async def check_database() -> bool:
    try:
        db = SessionLocal()
        db.execute("SELECT 1")
        db.close()
        return True
    except:
        return False

async def check_redis() -> bool:
    try:
        redis_client.ping()
        return True
    except:
        return False
```

## 🚨 Error Handling

### Custom Exception Handlers

```python
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    """Улучшенные ошибки валидации"""
    return JSONResponse(
        status_code=400,
        content={
            "detail": "Validation error",
            "errors": exc.errors()
        }
    )

@app.exception_handler(Exception)
async def general_exception_handler(request, exc):
    """Общий handler"""
    logger.error(f"Unhandled exception: {exc}", exc_info=True)
    
    return JSONResponse(
        status_code=500,
        content={"detail": "Internal server error"}
    )
```

## 📊 Key Endpoint Patterns

### Posts API

```python
# List with pagination
@app.get("/posts")
async def get_posts(
    user_id: int,
    channel_id: Optional[int] = None,
    limit: int = 50,
    offset: int = 0,
    db: Session = Depends(get_db)
):
    query = db.query(Post).filter(Post.user_id == user_id)
    if channel_id:
        query = query.filter(Post.channel_id == channel_id)
    
    posts = query.order_by(Post.posted_at.desc()).limit(limit).offset(offset).all()
    total = query.count()
    
    return {
        "posts": [serialize_post(p) for p in posts],
        "total": total,
        "pagination": {"limit": limit, "offset": offset}
    }

# Single item
@app.get("/posts/{post_id}")
async def get_post(post_id: int, user_id: int, db: Session = Depends(get_db)):
    post = db.query(Post).filter(
        Post.id == post_id,
        Post.user_id == user_id
    ).first()
    
    if not post:
        raise HTTPException(404, "Post not found")
    
    return serialize_post(post)
```

### QR Auth API

```python
# Mini App page
@app.get("/qr-auth", response_class=HTMLResponse)
async def qr_auth_page(session_id: str):
    session = await qr_auth_manager.get_qr_session(session_id)
    
    if not session:
        return "<h1>Session expired</h1>"
    
    return render_qr_auth_template(
        session_id=session_id,
        qr_image=generate_qr_code(session["deep_link"]),
        deep_link=session["deep_link"]
    )

# Status polling
@app.get("/qr-auth-status")
async def qr_auth_status(session_id: str):
    session = await qr_auth_manager.get_qr_session(session_id)
    return {"status": session.get("status", "expired") if session else "expired"}
```

### Admin API

```python
# Users list (admin only)
@app.get("/api/admin/users")
@require_admin
async def get_users_api(
    admin_id: int,
    token: str,
    role: Optional[str] = None,
    limit: int = 50,
    offset: int = 0,
    db: Session = Depends(get_db)
):
    query = db.query(User)
    if role:
        query = query.filter(User.role == role)
    
    users = query.limit(limit).offset(offset).all()
    return {"users": [serialize_user(u) for u in users]}

# Update subscription (admin only)
@app.post("/api/admin/user/{user_id}/subscription")
@require_admin
async def update_subscription(
    user_id: int,
    admin_id: int,
    token: str,
    subscription_type: str,
    db: Session = Depends(get_db)
):
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(404, "User not found")
    
    # Update
    user.subscription_type = subscription_type
    user.max_channels = SUBSCRIPTION_TIERS[subscription_type]["max_channels"]
    
    # Audit log
    admin = db.query(User).filter(User.telegram_id == admin_id).first()
    db.add(SubscriptionHistory(
        user_id=user.id,
        action="upgraded",
        old_type=user.subscription_type,
        new_type=subscription_type,
        changed_by=admin.id
    ))
    
    db.commit()
    return {"status": "success"}
```

## ✅ Verification Checklist

- [ ] All endpoints filter by `user_id`
- [ ] Admin endpoints use `@require_admin`
- [ ] Rate limiting on resource-intensive endpoints
- [ ] Pydantic models for validation
- [ ] Background tasks for long operations
- [ ] Health check endpoint exists
- [ ] Error handlers configured
- [ ] CORS configured for production domains
- [ ] API docs accessible at `/docs`

## ❌ Deprecated Patterns

**NEVER do this:**

```python
# ❌ No user filtering
@app.get("/posts")
async def get_posts(db: Session = Depends(get_db)):
    return db.query(Post).all()  # Data leak!

# ❌ Blocking operations
@app.post("/process")
async def process():
    time.sleep(10)  # Blocks event loop!
    return {"status": "done"}

# ❌ No rate limiting on RAG
@app.post("/rag/query")
async def rag_query(query: str):
    return await expensive_ai_call(query)  # Can be abused!

# ❌ Direct exception without logging
@app.get("/data")
async def get_data():
    raise Exception("Error")  # No context!

# ❌ CORS allow all in production
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"]  # Security risk!
)
```

## 🎯 Quick Examples

### ✅ Correct Patterns

```python
# User isolation
posts = db.query(Post).filter(Post.user_id == user_id).all()

# Background tasks
background_tasks.add_task(heavy_operation, user_id)

# Rate limiting
@rate_limit(limit=10, window=60)
async def expensive_endpoint():
    pass

# Validation
class Request(BaseModel):
    username: str = Field(..., min_length=1)

# Error handling
@app.exception_handler(ValueError)
async def value_error_handler(request, exc):
    return JSONResponse(status_code=400, content={"detail": str(exc)})
```

### ❌ Bad Patterns

```python
# No user filtering
posts = db.query(Post).all()

# Blocking
time.sleep(10)

# No rate limit
@app.post("/expensive")
async def expensive():
    pass

# No validation
@app.post("/data")
async def data(username: str):  # No length check!
    pass

# Silent errors
try:
    process()
except:
    pass  # No logging!
```

## 📚 Related Rules

- `01-core.mdc` — User filtering, async patterns
- `03-database.mdc` — Database dependencies
- `05-security.mdc` — Authentication
- `06-admin.mdc` — Admin endpoints
- `07-rag.mdc` — RAG endpoints
