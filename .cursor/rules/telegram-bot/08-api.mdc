---
title: "API Endpoints"
description: "FastAPI endpoints, —Å—Ç—Ä—É–∫—Ç—É—Ä–∞, authentication, best practices"
tags: ["api", "fastapi", "endpoints", "rest"]
version: "3.1"
---

# API Endpoints

## üéØ High-Level Overview

**FastAPI —Å–µ—Ä–≤–µ—Ä** (–ø–æ—Ä—Ç 8010) ‚Äî REST API –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å n8n, —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã–º–∏ –∏ Mini Apps.

**Stack:**
- FastAPI (async)
- Pydantic (validation)
- SQLAlchemy (ORM)
- CORS middleware

## üöÄ FastAPI Application

### Configuration

```python
# main.py
from fastapi import FastAPI, Depends, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse
from sqlalchemy.orm import Session
from typing import Optional, List

app = FastAPI(
    title="Telegram Channel Parser API",
    version="3.1.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # –í production - –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –¥–æ–º–µ–Ω—ã
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Database dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

## üìã API Categories

### 1. Posts Management

```python
@app.get("/posts")
async def get_posts(
    user_id: Optional[int] = None,
    channel_id: Optional[int] = None,
    limit: int = 50,
    offset: int = 0,
    db: Session = Depends(get_db)
):
    """
    –ü–æ–ª—É—á–∏—Ç—å –ø–æ—Å—Ç—ã —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π
    
    Query Parameters:
        user_id: ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏!)
        channel_id: –§–∏–ª—å—Ç—Ä –ø–æ –∫–∞–Ω–∞–ª—É
        limit: –ú–∞–∫—Å. –ø–æ—Å—Ç–æ–≤ (default: 50)
        offset: –°–º–µ—â–µ–Ω–∏–µ (pagination)
    """
    # ‚úÖ –í–°–ï–ì–î–ê —Ñ–∏–ª—å—Ç—Ä—É–π—Ç–µ –ø–æ user_id
    if not user_id:
        raise HTTPException(400, "user_id required")
    
    query = db.query(Post).join(Post.channel).join(Channel.users).filter(
        User.id == user_id
    )
    
    if channel_id:
        query = query.filter(Post.channel_id == channel_id)
    
    posts = query.order_by(Post.posted_at.desc()).limit(limit).offset(offset).all()
    total = query.count()
    
    return {
        "posts": [serialize_post(p) for p in posts],
        "total": total,
        "limit": limit,
        "offset": offset
    }

@app.get("/posts/{post_id}")
async def get_post(
    post_id: int,
    user_id: int,
    db: Session = Depends(get_db)
):
    """
    –ü–æ–ª—É—á–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –ø–æ—Å—Ç
    """
    post = db.query(Post).join(Post.channel).join(Channel.users).filter(
        Post.id == post_id,
        User.id == user_id
    ).first()
    
    if not post:
        raise HTTPException(404, "Post not found")
    
    return serialize_post(post)
```

### 2. Channels Management

```python
@app.get("/channels")
async def get_channels(
    user_id: int,
    db: Session = Depends(get_db)
):
    """
    –°–ø–∏—Å–æ–∫ –∫–∞–Ω–∞–ª–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    """
    user = db.query(User).filter(User.id == user_id).first()
    
    if not user:
        raise HTTPException(404, "User not found")
    
    return {
        "channels": [
            {
                "id": ch.id,
                "username": ch.channel_username,
                "posts_count": len(ch.posts)
            }
            for ch in user.channels
        ]
    }

@app.post("/channels")
async def add_channel(
    user_id: int,
    channel_username: str,
    db: Session = Depends(get_db)
):
    """
    –î–æ–±–∞–≤–∏—Ç—å –∫–∞–Ω–∞–ª
    """
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–∞
    user = db.query(User).filter(User.id == user_id).first()
    
    if not user:
        raise HTTPException(404, "User not found")
    
    if len(user.channels) >= user.max_channels:
        raise HTTPException(
            403,
            f"Channel limit reached: {user.max_channels}"
        )
    
    # –°–æ–∑–¥–∞–Ω–∏–µ/–ø–æ–ª—É—á–µ–Ω–∏–µ –∫–∞–Ω–∞–ª–∞
    channel = db.query(Channel).filter(
        Channel.channel_username == channel_username
    ).first()
    
    if not channel:
        channel = Channel(channel_username=channel_username)
        db.add(channel)
    
    # –°–≤—è–∑—å
    if channel not in user.channels:
        user.channels.append(channel)
    
    db.commit()
    
    return {"status": "success", "channel_id": channel.id}
```

### 3. QR Auth Endpoints

```python
@app.get("/qr-auth", response_class=HTMLResponse)
async def qr_auth_page(session_id: str):
    """
    QR Auth Mini App
    """
    # –ü–æ–ª—É—á–∞–µ–º session
    session = await qr_auth_manager.get_qr_session(session_id)
    
    if not session:
        return "<h1>Session expired</h1>"
    
    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º QR –∫–æ–¥
    qr_image_base64 = generate_qr_code(session["deep_link"])
    
    # HTML —Å Telegram Mini App integration
    html = render_qr_auth_template(
        session_id=session_id,
        qr_image=qr_image_base64,
        deep_link=session["deep_link"],
        token=session["token"]
    )
    
    return html

@app.get("/qr-auth-status")
async def qr_auth_status(session_id: str):
    """
    –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ QR session
    """
    session = await qr_auth_manager.get_qr_session(session_id)
    
    if not session:
        return {"status": "expired"}
    
    return {"status": session.get("status", "waiting")}
```

### 4. Admin Panel Endpoints

```python
@app.get("/admin-panel", response_class=HTMLResponse)
async def admin_panel(admin_id: int, token: str):
    """
    Admin Panel Mini App (SPA)
    """
    # Verify session
    if not admin_panel_manager.verify_admin_session(token, admin_id):
        return "<h1>Unauthorized</h1>"
    
    # HTML SPA
    html = render_admin_panel_template(
        admin_id=admin_id,
        token=token
    )
    
    return html

@app.get("/api/admin/users")
@require_admin
async def get_users_api(
    admin_id: int,
    token: str,
    role: Optional[str] = None,
    subscription: Optional[str] = None,
    search: Optional[str] = None,
    limit: int = 50,
    offset: int = 0,
    db: Session = Depends(get_db)
):
    """
    –°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (admin only)
    """
    query = db.query(User)
    
    # –§–∏–ª—å—Ç—Ä—ã
    if role:
        query = query.filter(User.role == role)
    
    if subscription:
        query = query.filter(User.subscription_type == subscription)
    
    if search:
        query = query.filter(User.username.ilike(f"%{search}%"))
    
    users = query.limit(limit).offset(offset).all()
    total = query.count()
    
    return {
        "users": [serialize_user(u) for u in users],
        "total": total
    }

@app.post("/api/admin/user/{user_id}/subscription")
@require_admin
async def update_subscription(
    user_id: int,
    admin_id: int,
    token: str,
    subscription_type: str,
    duration_days: Optional[int] = None,
    db: Session = Depends(get_db)
):
    """
    –ò–∑–º–µ–Ω–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É (admin only)
    """
    user = db.query(User).filter(User.id == user_id).first()
    
    if not user:
        raise HTTPException(404, "User not found")
    
    # Update subscription
    old_subscription = user.subscription_type
    user.subscription_type = subscription_type
    
    # Set expiry
    if duration_days:
        user.subscription_expires = (
            datetime.now(timezone.utc) + timedelta(days=duration_days)
        )
    
    # Update max_channels
    tier = SUBSCRIPTION_TIERS.get(subscription_type, {})
    user.max_channels = tier.get("max_channels", 3)
    
    # Audit log
    admin = db.query(User).filter(User.telegram_id == admin_id).first()
    history = SubscriptionHistory(
        user_id=user.id,
        action="upgraded",
        old_type=old_subscription,
        new_type=subscription_type,
        changed_by=admin.id,
        notes="Admin panel change"
    )
    db.add(history)
    
    db.commit()
    
    return {"status": "success", "user": serialize_user(user)}
```

### 5. Parsing Endpoints

```python
@app.post("/parse_all_channels")
async def parse_all_channels(
    user_id: Optional[int] = None,
    background_tasks: BackgroundTasks = BackgroundTasks(),
    db: Session = Depends(get_db)
):
    """
    –ó–∞–ø—É—Å—Ç–∏—Ç—å –ø–∞—Ä—Å–∏–Ω–≥ –≤—Å–µ—Ö –∫–∞–Ω–∞–ª–æ–≤ (background)
    """
    if user_id:
        # –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
        background_tasks.add_task(
            parser_service.parse_user_channels,
            user_id
        )
    else:
        # –í—Å–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏
        background_tasks.add_task(
            parser_service.parse_all_users
        )
    
    return {"status": "queued"}

@app.get("/parsing/status/{user_id}")
async def parsing_status(
    user_id: int,
    db: Session = Depends(get_db)
):
    """
    –°—Ç–∞—Ç—É—Å –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    """
    # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –ø–∞—Ä—Å–∏–Ω–≥
    last_parse = parser_service.get_last_parse_time(user_id)
    
    return {
        "user_id": user_id,
        "last_parse": last_parse.isoformat() if last_parse else None,
        "next_parse": (last_parse + timedelta(minutes=30)).isoformat() if last_parse else None
    }
```

### 6. Health Check

```python
@app.get("/health")
async def health_check():
    """
    Comprehensive health check
    """
    checks = {
        "database": await check_database(),
        "redis": await check_redis(),
        "qdrant": await check_qdrant(),
        "gigachat_proxy": await check_gigachat()
    }
    
    all_healthy = all(checks.values())
    status = "healthy" if all_healthy else "degraded"
    
    return {
        "status": status,
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "checks": checks,
        "version": "3.1.0"
    }

async def check_database() -> bool:
    try:
        db = SessionLocal()
        db.execute("SELECT 1")
        db.close()
        return True
    except:
        return False

async def check_redis() -> bool:
    try:
        redis_client.ping()
        return True
    except:
        return False
```

## üîê Security Patterns

### Authentication Decorator

```python
def require_user_auth(func):
    """
    –¢—Ä–µ–±—É–µ—Ç –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    """
    @wraps(func)
    async def wrapper(*args, **kwargs):
        user_id = kwargs.get('user_id')
        
        if not user_id:
            raise HTTPException(401, "user_id required")
        
        db = SessionLocal()
        user = db.query(User).filter(User.id == user_id).first()
        
        if not user or not user.is_authenticated:
            db.close()
            raise HTTPException(401, "User not authenticated")
        
        db.close()
        return await func(*args, **kwargs)
    
    return wrapper
```

### Rate Limiting

```python
from functools import wraps

def rate_limit(limit: int = 10, window: int = 60):
    """
    Rate limiting –¥–µ–∫–æ—Ä–∞—Ç–æ—Ä
    
    Args:
        limit: –ú–∞–∫—Å. –∑–∞–ø—Ä–æ—Å–æ–≤
        window: –û–∫–Ω–æ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
    """
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            user_id = kwargs.get('user_id')
            
            if not user_id:
                return await func(*args, **kwargs)
            
            # Redis rate limit
            key = f"rate:{user_id}:{func.__name__}"
            current = redis_client.incr(key)
            
            if current == 1:
                redis_client.expire(key, window)
            
            if current > limit:
                raise HTTPException(
                    429,
                    f"Rate limit exceeded: {limit} requests per {window}s"
                )
            
            return await func(*args, **kwargs)
        
        return wrapper
    
    return decorator

# Usage
@app.post("/rag/query")
@rate_limit(limit=10, window=60)
async def rag_query_endpoint(user_id: int, query: str):
    pass
```

## üìù Pydantic Models

### Request/Response Schemas

```python
from pydantic import BaseModel, Field
from typing import Optional, List

class PostResponse(BaseModel):
    id: int
    text: str
    channel_username: str
    posted_at: str
    url: Optional[str]
    tags: List[str] = []
    
    class Config:
        orm_mode = True

class ChannelCreate(BaseModel):
    channel_username: str = Field(..., min_length=1)

class UserUpdate(BaseModel):
    subscription_type: Optional[str] = None
    max_channels: Optional[int] = Field(None, ge=1, le=999)
    role: Optional[str] = Field(None, pattern="^(admin|user)$")
```

## ‚úÖ Verification Steps

1. **API –¥–æ—Å—Ç—É–ø–µ–Ω:**
```bash
curl http://localhost:8010/health
# {"status": "healthy"}
```

2. **Docs –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç—Å—è:**
```bash
curl http://localhost:8010/docs
# HTML with Swagger UI
```

3. **CORS –Ω–∞—Å—Ç—Ä–æ–µ–Ω:**
```bash
curl -H "Origin: http://example.com" \
     -H "Access-Control-Request-Method: POST" \
     -X OPTIONS http://localhost:8010/posts
# Should return CORS headers
```

4. **Rate limiting —Ä–∞–±–æ—Ç–∞–µ—Ç:**
```python
# 11-–π –∑–∞–ø—Ä–æ—Å –∑–∞ –º–∏–Ω—É—Ç—É
for i in range(11):
    response = requests.post("/rag/query", json={"user_id": 1, "query": "test"})

assert response.status_code == 429  # Rate limit exceeded
```

5. **Background tasks —Ä–∞–±–æ—Ç–∞—é—Ç:**
```python
response = requests.post("/parse_all_channels?user_id=1")
assert response.json()["status"] == "queued"
```

## üö® Error Handling

### Custom Exception Handler

```python
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    """
    –£–ª—É—á—à–µ–Ω–Ω—ã–µ –æ—à–∏–±–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
    """
    return JSONResponse(
        status_code=400,
        content={
            "detail": "Validation error",
            "errors": exc.errors()
        }
    )

@app.exception_handler(Exception)
async def general_exception_handler(request, exc):
    """
    –û–±—â–∏–π handler –¥–ª—è –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω—ã—Ö –æ—à–∏–±–æ–∫
    """
    logger.error(f"Unhandled exception: {exc}", exc_info=True)
    
    return JSONResponse(
        status_code=500,
        content={
            "detail": "Internal server error"
        }
    )
```

## üìö –°–≤—è–∑–∞–Ω–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞

- `01-core.mdc` ‚Äî –û—Å–Ω–æ–≤–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞
- `05-security.mdc` ‚Äî Authentication
- `06-admin.mdc` ‚Äî Admin endpoints
- `07-rag.mdc` ‚Äî RAG endpoints
