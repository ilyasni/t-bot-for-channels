---
title: "Security & Authentication"
description: "QR Login, —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ, sessions, –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å"
tags: ["security", "authentication", "qr-login", "encryption"]
version: "3.1"
---

# Security & Authentication

## üéØ High-Level Overview

**QR Login —Å–∏—Å—Ç–µ–º–∞** (v3.1) ‚Äî –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ë–ï–ó SMS –∫–æ–¥–æ–≤ —á–µ—Ä–µ–∑ Telegram Mini App.

**Stack:**
- Telethon QR Login API
- Redis –¥–ª—è sessions (shared state)
- Fernet encryption –¥–ª—è credentials
- Master credentials –ø–æ–¥—Ö–æ–¥

## üîê QR Login System (v3.1)

### –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞

```
User (/login CODE)
    ‚Üì
Bot —Å–æ–∑–¥–∞–µ—Ç QR session
    ‚Üì
Redis (qr_session:id, TTL 10 –º–∏–Ω)
    ‚Üì
Mini App –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç QR
    ‚Üì
User —Å–∫–∞–Ω–∏—Ä—É–µ—Ç QR
    ‚Üì
Telethon client.qr_login().wait()
    ‚Üì
Authorization finalized
    ‚Üì
Session —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤ shared_auth_manager
```

### QR Auth Manager

```python
# qr_auth_manager.py
import redis
import json
import uuid
from telethon import TelegramClient
from datetime import datetime, timezone, timedelta

class QRAuthManager:
    def __init__(self):
        # Redis –¥–ª—è shared state –º–µ–∂–¥—É telethon-bot –∏ telethon
        self.redis_client = redis.Redis(
            host=os.getenv("REDIS_HOST", "redis"),
            port=int(os.getenv("REDIS_PORT", 6379)),
            decode_responses=True
        )
        self.session_ttl = 600  # 10 –º–∏–Ω—É—Ç
    
    async def create_qr_session(
        self,
        telegram_id: int,
        invite_code: str
    ) -> Optional[str]:
        """
        –°–æ–∑–¥–∞—Ç—å QR session
        
        Returns:
            session_id –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ Mini App
        """
        session_id = str(uuid.uuid4())
        
        # 1. –°–æ–∑–¥–∞—ë–º Telethon client —Å master credentials
        client = TelegramClient(
            f"sessions/qr_{session_id}",
            api_id=MASTER_API_ID,
            api_hash=MASTER_API_HASH
        )
        
        await client.connect()
        
        # 2. –í—ã–∑—ã–≤–∞–µ–º client.qr_login()
        qr_login = await client.qr_login()
        
        # 3. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º deep link
        token = qr_login.url.split('token=')[1]
        deep_link = f"tg://login?token={token}"
        
        # 4. –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ Redis —Å TTL
        session_data = {
            "telegram_id": telegram_id,
            "invite_code": invite_code,
            "token": token,
            "deep_link": deep_link,
            "status": "waiting",
            "created_at": datetime.now(timezone.utc).isoformat()
        }
        
        self.redis_client.setex(
            f"qr_session:{session_id}",
            self.session_ttl,
            json.dumps(session_data)
        )
        
        # 5. –ó–∞–ø—É—Å–∫–∞–µ–º background polling
        asyncio.create_task(
            self._poll_authorization(session_id, qr_login, client)
        )
        
        return session_id
    
    async def _poll_authorization(
        self,
        session_id: str,
        qr_login,
        client: TelegramClient
    ):
        """
        Polling authorization status
        """
        try:
            # –ñ–¥—ë–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è (–¥–æ 10 –º–∏–Ω—É—Ç)
            await qr_login.wait(timeout=600)
            
            # Authorization —É—Å–ø–µ—à–Ω–∞
            await self._finalize_authorization(session_id, client)
            
        except asyncio.TimeoutError:
            # –ò—Å—Ç–µ–∫–ª–æ –≤—Ä–µ–º—è
            await self._update_session_status(session_id, "expired")
        except Exception as e:
            logger.error(f"Authorization error: {e}")
            await self._update_session_status(session_id, "error")
        finally:
            await client.disconnect()
    
    async def _finalize_authorization(
        self,
        session_id: str,
        client: TelegramClient
    ):
        """
        –§–∏–Ω–∞–ª–∏–∑–∞—Ü–∏—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
        """
        # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º ownership
        me = await client.get_me()
        
        session = await self.get_qr_session(session_id)
        if not session:
            return
        
        if me.id != session["telegram_id"]:
            logger.error("Ownership mismatch!")
            return
        
        # 2. –°–æ—Ö—Ä–∞–Ω—è–µ–º session –≤ shared_auth_manager
        session_string = client.session.save()
        await shared_auth_manager.save_session(
            telegram_id=me.id,
            session_string=session_string
        )
        
        # 3. –û–±–Ω–æ–≤–ª—è–µ–º user.is_authenticated = True
        db = SessionLocal()
        user = db.query(User).filter(
            User.telegram_id == me.id
        ).first()
        
        if user:
            user.is_authenticated = True
            
            # 4. –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º –ø–æ–¥–ø–∏—Å–∫—É –∏–∑ invite code
            invite_code = session["invite_code"]
            await self._activate_subscription(user, invite_code, db)
            
            # 5. –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º max_channels
            tier = SUBSCRIPTION_TIERS.get(user.subscription_type, {})
            user.max_channels = tier.get("max_channels", 3)
            
            db.commit()
        
        db.close()
        
        # 6. –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –≤ Redis
        await self._update_session_status(session_id, "authorized")
```

### Mini App UI

```python
# main.py (FastAPI endpoint)
from fastapi import FastAPI, Request
from fastapi.responses import HTMLResponse
import qrcode
from io import BytesIO
import base64

@app.get("/qr-auth", response_class=HTMLResponse)
async def qr_auth_page(session_id: str):
    """
    QR Auth Mini App
    """
    # 1. –ü–æ–ª—É—á–∞–µ–º session –∏–∑ Redis
    session = await qr_auth_manager.get_qr_session(session_id)
    
    if not session:
        return "<h1>Session expired</h1>"
    
    # 2. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º QR –∫–æ–¥
    qr = qrcode.QRCode(version=1, box_size=10, border=5)
    qr.add_data(session["deep_link"])
    qr.make(fit=True)
    
    img = qr.make_image(fill_color="black", back_color="white")
    
    # Convert to base64
    buffer = BytesIO()
    img.save(buffer, format="PNG")
    img_str = base64.b64encode(buffer.getvalue()).decode()
    
    # 3. HTML —Å QR + Deep Link –∫–Ω–æ–ø–∫–∞ + Polling
    html = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="https://telegram.org/js/telegram-web-app.js"></script>
        <script src="https://cdn.tailwindcss.com"></script>
    </head>
    <body class="bg-gray-100 dark:bg-gray-900">
        <div class="container mx-auto p-4 text-center">
            <h1 class="text-2xl font-bold mb-4">üì± QR –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è</h1>
            
            <!-- QR Code -->
            <img src="data:image/png;base64,{img_str}" 
                 class="mx-auto mb-4" 
                 style="max-width: 300px;">
            
            <!-- Deep Link Button -->
            <button id="loginBtn" 
                    class="bg-blue-500 text-white px-6 py-3 rounded-lg">
                –í–æ–π—Ç–∏ —á–µ—Ä–µ–∑ Telegram
            </button>
            
            <!-- Copy Token -->
            <button id="copyBtn" 
                    class="mt-2 bg-gray-500 text-white px-4 py-2 rounded">
                üìã –°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–∫–µ–Ω
            </button>
            
            <p id="status" class="mt-4">‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏...</p>
        </div>
        
        <script>
            const tg = window.Telegram.WebApp;
            tg.ready();
            tg.expand();
            
            const sessionId = "{session_id}";
            const deepLink = "{session["deep_link"]}";
            const token = "{session["token"]}";
            
            // Deep link button
            document.getElementById('loginBtn').onclick = () => {{
                tg.openTelegramLink(deepLink);
            }};
            
            // Copy token button
            document.getElementById('copyBtn').onclick = () => {{
                navigator.clipboard.writeText(token);
                tg.showAlert('‚úÖ –¢–æ–∫–µ–Ω —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω!');
            }};
            
            // Polling status
            let pollInterval = setInterval(async () => {{
                const response = await fetch(`/qr-auth-status?session_id=${{sessionId}}`);
                const data = await response.json();
                
                if (data.status === 'authorized') {{
                    document.getElementById('status').innerHTML = 
                        '‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞!';
                    clearInterval(pollInterval);
                    
                    setTimeout(() => {{
                        tg.close();
                    }}, 2000);
                }} else if (data.status === 'expired') {{
                    document.getElementById('status').innerHTML = 
                        '‚ùå –í—Ä–µ–º—è –∏—Å—Ç–µ–∫–ª–æ. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.';
                    clearInterval(pollInterval);
                }} else if (data.status === 'error') {{
                    document.getElementById('status').innerHTML = 
                        '‚ùå –û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏.';
                    clearInterval(pollInterval);
                }}
            }}, 2000);
            
            // Visibility change - –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ
            document.addEventListener('visibilitychange', async () => {{
                if (!document.hidden) {{
                    const response = await fetch(`/qr-auth-status?session_id=${{sessionId}}`);
                    const data = await response.json();
                    
                    if (data.status === 'authorized') {{
                        tg.showAlert('‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞!', () => {{
                            tg.close();
                        }});
                    }}
                }}
            }});
        </script>
    </body>
    </html>
    """
    
    return html

@app.get("/qr-auth-status")
async def qr_auth_status(session_id: str):
    """
    Check QR session status
    """
    session = await qr_auth_manager.get_qr_session(session_id)
    
    if not session:
        return {"status": "expired"}
    
    return {"status": session.get("status", "waiting")}
```

### Bot Handler

```python
# bot_login_handlers_qr.py
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, ConversationHandler

WAITING_QR_SCAN = 1

async def login_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    /login INVITE_CODE
    """
    # 1. –í–∞–ª–∏–¥–∞—Ü–∏—è invite code
    args = context.args
    if not args:
        await update.message.reply_text("‚ùå –£–∫–∞–∂–∏—Ç–µ –∏–Ω–≤–∞–π—Ç –∫–æ–¥:\n/login YOUR_CODE")
        return ConversationHandler.END
    
    invite_code = args[0]
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏
    db = SessionLocal()
    invite = db.query(InviteCode).filter(
        InviteCode.code == invite_code
    ).first()
    
    if not invite or not invite.is_valid():
        await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –∏–ª–∏ –∏—Å—Ç–µ–∫—à–∏–π –∫–æ–¥")
        db.close()
        return ConversationHandler.END
    
    db.close()
    
    # 2. –°–æ–∑–¥–∞–Ω–∏–µ/–ø–æ–ª—É—á–µ–Ω–∏–µ user
    telegram_id = update.effective_user.id
    
    # 3. –°–æ–∑–¥–∞–Ω–∏–µ QR session
    session_id = await qr_auth_manager.create_qr_session(
        telegram_id=telegram_id,
        invite_code=invite_code
    )
    
    if not session_id:
        await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å–µ—Å—Å–∏–∏")
        return ConversationHandler.END
    
    # 4. –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–Ω–æ–ø–∫–∏ —Å WebAppInfo
    qr_url = f"https://telegram-auth.produman.studio/qr-auth?session_id={session_id}"
    
    keyboard = [
        [InlineKeyboardButton(
            "üì± –û—Ç–∫—Ä—ã—Ç—å QR-–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é",
            web_app=WebAppInfo(url=qr_url)
        )]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "üîê QR –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è\n\n"
        "1Ô∏è‚É£ –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ\n"
        "2Ô∏è‚É£ –û—Ç—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ QR-–∫–æ–¥ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '–í–æ–π—Ç–∏'\n"
        "3Ô∏è‚É£ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –≤ Telegram\n"
        "4Ô∏è‚É£ –ì–æ—Ç–æ–≤–æ!\n\n"
        "‚è± –í—Ä–µ–º—è: 10 –º–∏–Ω—É—Ç",
        reply_markup=reply_markup
    )
    
    # 5. –ñ–¥—ë–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
    context.user_data['qr_session_id'] = session_id
    
    return WAITING_QR_SCAN
```

## üîí Encryption

### Credentials Encryption

```python
# crypto_utils.py
from cryptography.fernet import Fernet
import os

# ENCRYPTION_KEY –∏–∑ .env (–æ–±—â–∏–π —Å –æ—Å–Ω–æ–≤–Ω—ã–º –ø—Ä–æ–µ–∫—Ç–æ–º)
ENCRYPTION_KEY = os.getenv("ENCRYPTION_KEY")
if not ENCRYPTION_KEY:
    raise ValueError("ENCRYPTION_KEY –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω!")

cipher = Fernet(ENCRYPTION_KEY.encode())

def encrypt_data(data: str) -> str:
    """–®–∏—Ñ—Ä—É–µ—Ç –¥–∞–Ω–Ω—ã–µ"""
    return cipher.encrypt(data.encode()).decode()

def decrypt_data(encrypted: str) -> str:
    """–†–∞—Å—à–∏—Ñ—Ä–æ–≤—ã–≤–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ"""
    return cipher.decrypt(encrypted.encode()).decode()
```

### Usage in Models

```python
# models.py
class User(Base):
    # –ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–µ credentials (–ù–ï –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤ v3.1)
    # –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è master credentials
    api_id_encrypted = Column(String, nullable=True)
    api_hash_encrypted = Column(String, nullable=True)
    
    def get_decrypted_api_id(self) -> Optional[int]:
        if self.api_id_encrypted:
            return int(decrypt_data(self.api_id_encrypted))
        return None
```

## ‚úÖ Verification Steps

1. **Redis –¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è QR sessions:**
```bash
docker exec redis redis-cli KEYS "qr_session:*"
# –î–æ–ª–∂–µ–Ω –ø–æ–∫–∞–∑–∞—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–µ sessions
```

2. **QR Login —Ä–∞–±–æ—Ç–∞–µ—Ç:**
```python
# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è session
session_id = await qr_auth_manager.create_qr_session(123, "TEST")
assert session_id is not None
```

3. **Encryption —Ä–∞–±–æ—Ç–∞–µ—Ç:**
```python
encrypted = encrypt_data("test_data")
decrypted = decrypt_data(encrypted)
assert decrypted == "test_data"
```

4. **Mini App –¥–æ—Å—Ç—É–ø–µ–Ω:**
```bash
curl https://telegram-auth.produman.studio/qr-auth?session_id=test
# –î–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å HTML
```

5. **Session TTL —Ä–∞–±–æ—Ç–∞–µ—Ç:**
```bash
# Session –¥–æ–ª–∂–µ–Ω –∏—Å—Ç–µ—á—å —á–µ—Ä–µ–∑ 10 –º–∏–Ω—É—Ç
docker exec redis redis-cli TTL "qr_session:test-id"
# 600 —Å–µ–∫—É–Ω–¥
```

## üö® Troubleshooting

### QR Login –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç

```bash
# 1. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ Redis
docker logs telethon | grep "QRAuthManager"
# –î–æ–ª–∂–Ω–æ –±—ã—Ç—å: ‚úÖ QRAuthManager –ø–æ–¥–∫–ª—é—á–µ–Ω

# 2. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ session –≤ Redis
docker exec redis redis-cli KEYS "qr_session:*"

# 3. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ polling
docker logs telethon | grep "poll_authorization"
```

### Master credentials

```bash
# –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ MASTER_API_ID –∏ MASTER_API_HASH —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã
docker exec telethon printenv | grep MASTER_
```

## üìö –°–≤—è–∑–∞–Ω–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞

- `01-core.mdc` ‚Äî –û—Å–Ω–æ–≤–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞
- `03-database.mdc` ‚Äî Redis, sessions
- `06-admin.mdc` ‚Äî Admin sessions
